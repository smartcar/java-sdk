plugins {
    id 'java-library'
    id 'maven-publish'
    id 'signing'

    id 'com.adarshr.test-logger' version '2.1.1'
    id 'org.unbroken-dome.test-sets' version '4.0.0'
}

apply plugin: 'jacoco'

group libGroup
version libVersion

java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    withJavadocJar()
    withSourcesJar()
}

repositories {
    mavenCentral()
    jcenter() {
        content {
            includeModule("org.testng", "testng")
        }
    }
}

/**
 * Defines test sets:
 *  - Unit Tests (test)  <-- existing default
 *  - Integration (integration)
 *
 * @plugin org.unbroken-dome.test-sets
 */
testSets {
    integration
}

/**
 * Defines all dependencies.
 *
 * @see https://docs.gradle.org/6.0.1/userguide/java_library_plugin.html#sec:java_library_configurations_graph
 */
dependencies {
    api 'com.google.code.gson:gson:2.10.1'
    api 'com.squareup.okhttp3:okhttp:4.9.1'
    implementation 'org.apache.commons:commons-text:1.2'
    implementation 'javax.json:javax.json-api:1.0'  // Java EE interfaces
    runtimeOnly 'org.glassfish:javax.json:1.1'      // implementation for above interfaces
    implementation 'commons-codec:commons-codec:1.10'

    testImplementation 'com.squareup.okhttp3:mockwebserver:4.9.1'
    testImplementation 'org.powermock:powermock-release-with-testng-mockito-dependencies:1.6.2'
    testImplementation 'org.testng:testng:7.4.0'

    integrationImplementation 'org.seleniumhq.selenium:selenium-java:4.11.0'
}

/**
 * Generates Javadoc for the SDK.
 *
 * @plugin java
 */
javadoc {
    destinationDir = file('docs')

    options.header = libDescription
    options.windowTitle = "${libName} - ${libVersion}"
    options.addBooleanOption('notimestamp', true)
}

/**
 * Customizes the jar MANIFEST.MF for generated jars.
 *
 * @plugin java
 */
jar {
    manifest {
        attributes('Implementation-Title': libName,
                'Implementation-Version': libVersion)
    }
}

/**
 * Configures all test tasks.
 *
 * @plugin com.adarshr.test-logger
 * @plugin java
 */
tasks.withType(Test) {
    useTestNG {
        preserveOrder true
    }

    testlogger {
        theme 'mocha'
        showStandardStreams true
        showPassedStandardStreams false
        showSkippedStandardStreams false
        showFailedStandardStreams true
        showFullStackTraces true
    }
}

check.dependsOn integration

/**
 * Configures coverage reporting.
 *
 * @plugin jacoco
 */
jacoco {
    reportsDirectory = file("${buildDir}/reports/coverage")
}

/**
 * Generates coverage reports for the unit tests.
 *
 * @plugin jacoco
 */
jacocoTestReport {
    reports {
        html.enabled = true
        html.destination = file("${buildDir}/reports/coverage/test/html")

        xml.enabled = true
        xml.destination = file("${buildDir}/reports/coverage/test/report.xml")
    }
}

/**
 * Generates coverage reports for the integration tests.
 *
 * @plugin jacoco
 */
jacocoIntegrationReport {
    dependsOn integration

    reports {
        html.enabled = true
        html.destination = file("${buildDir}/reports/coverage/integration/html")

        xml.enabled = true
        xml.destination = file("${buildDir}/reports/coverage/integration/report.xml")
    }
}

/**
 * Generates all coverage reports after running tests.
 *
 * @plugin jacoco
 */
task coverage {
    dependsOn check
    dependsOn jacocoTestReport
    dependsOn jacocoIntegrationReport
}

/**
 * Generates updated markdown documentation using the markdown template files.
 */
task markdown(type: Copy) {
    def date = new Date()
    def licenseYear = date.format('yyyy')

    from './'
    into './'
    include '*.mdt'
    rename '^(.*)\\.mdt$', '$1.md'
    expand(libGroup: libGroup, libName: libName, libVersion: libVersion, year: licenseYear)
    filteringCharset = 'UTF-8'
}

/**
 * Configures packaging of modules/artifacts to publish.
 *
 * @plugin maven-publish
 */
publishing {
    publications {
        main(MavenPublication) {
            from components.java

            artifactId libName

            pom {
                // https://central.sonatype.org/publish/requirements/#sufficient-metadata
                name = libName
                description = 'Java SDK for the Smartcar platform'
                url = 'https://github.com/smartcar/java-sdk'

                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                    }
                }

                developers {
                    developer {
                        id = 'smartcar'
                        name = 'Smartcar'
                        email = 'hello@smartcar.com'
                    }
                }

                scm {
                    connection = 'scm:git:git://github.com/smartcar/java-sdk.git'
                    developerConnection = 'scm:git:ssh://github.com:smartcar/java-sdk.git'
                    url = 'https://github.com/smartcar/java-sdk.git'
                }
            }
        }
    }

}



/**
 * Requires the following environment variables to be set:
 *  - ORG_GRADLE_PROJECT_signingKey
 *  - ORG_GRADLE_PROJECT_signingPassword
 *
 * @see https://docs.gradle.org/current/userguide/signing_plugin.html#sec:in-memory-keys
 */
signing {
    def signingKey = findProperty("signingKey")
    def signingPassword = findProperty("signingPassword")
    
    // Always set up signing but only require it if keys are available
    required { signingKey != null && signingPassword != null }
    
    if (signingKey != null && signingPassword != null) {
        useInMemoryPgpKeys signingKey, signingPassword
    }
    
    sign publishing.publications.main
}

/**
 * Custom task to upload artifacts to Sonatype Central
 * Requires the following environment variables to be set:
 *  - ORG_GRADLE_PROJECT_sonatypeUsername (Central Portal username)
 *  - ORG_GRADLE_PROJECT_sonatypePassword (Central Portal password)
 */
task uploadToSonatypeCentral {
    group = 'publishing'
    description = 'Uploads signed artifacts to Sonatype Central Portal'
    
    dependsOn 'signMainPublication'
    
    doLast {
        def username = findProperty("sonatypeUsername")
        def password = findProperty("sonatypePassword")
        
        if (!username || !password) {
            throw new GradleException("Missing Sonatype Central credentials. Set ORG_GRADLE_PROJECT_sonatypeUsername and ORG_GRADLE_PROJECT_sonatypePassword")
        }
        
        // Get the published artifacts from local repository
        def localRepo = "${System.getProperty('user.home')}/.m2/repository"
        def groupPath = libGroup.replace('.', '/')
        def artifactPath = "${localRepo}/${groupPath}/${libName}/${libVersion}"
        
        println "Preparing upload bundle for ${libGroup}:${libName}:${libVersion}"
        
        // Create a temporary directory for the bundle with proper Maven structure
        def bundleDir = file("${buildDir}/sonatype-bundle")
        def mavenDir = file("${bundleDir}/${groupPath}/${libName}/${libVersion}")
        mavenDir.mkdirs()
        
        // Copy all artifacts to proper Maven directory structure
        copy {
            from artifactPath
            into mavenDir
            include '*.jar', '*.pom', '*.module', '*.asc', '*.md5', '*.sha1'
        }
        
        // Generate missing checksums and signatures if needed
        def artifactFiles = fileTree(mavenDir).matching {
            include '*.jar', '*.pom', '*.module'
            exclude '*.asc', '*.md5', '*.sha1'
        }
        
        artifactFiles.each { file ->
            def fileName = file.name
            
            // Generate MD5 checksum
            def md5File = new File(mavenDir, "${fileName}.md5")
            if (!md5File.exists()) {
                def md5Hash = java.security.MessageDigest.getInstance("MD5")
                    .digest(file.bytes)
                    .encodeHex()
                    .toString()
                md5File.text = md5Hash
                println "Generated MD5 for ${fileName}: ${md5Hash}"
            }
            
            // Generate SHA1 checksum
            def sha1File = new File(mavenDir, "${fileName}.sha1")
            if (!sha1File.exists()) {
                def sha1Hash = java.security.MessageDigest.getInstance("SHA-1")
                    .digest(file.bytes)
                    .encodeHex()
                    .toString()
                sha1File.text = sha1Hash
                println "Generated SHA1 for ${fileName}: ${sha1Hash}"
            }
            
            // Check for signature
            def sigFile = new File(mavenDir, "${fileName}.asc")
            if (!sigFile.exists()) {
                println "Warning: Missing signature for ${fileName}"
            }
        }
        
        // List all files in the bundle
        println "Bundle contents:"
        fileTree(bundleDir).each { file ->
            def relativePath = bundleDir.toPath().relativize(file.toPath()).toString()
            println "  ${relativePath}"
        }
        
        // Create the upload bundle (zip file)
        def bundleFile = file("${buildDir}/sonatype-bundle.zip")
        ant.zip(destfile: bundleFile) {
            fileset(dir: bundleDir)
        }
        
        println "Created bundle: ${bundleFile.absolutePath} (${bundleFile.length()} bytes)"
        
        // Upload to Sonatype Central using curl
        def curlCommand = [
            'curl', '-X', 'POST',
            '--header', 'accept: application/json',
            '--form', "bundle=@${bundleFile.absolutePath}",
            '--user', "${username}:${password}",
            '--silent', '--show-error',
            'https://central.sonatype.com/api/v1/publisher/upload'
        ]
        
        println "Uploading to Sonatype Central..."
        def process = curlCommand.execute()
        
        def outputStream = new ByteArrayOutputStream()
        def errorStream = new ByteArrayOutputStream()
        
        process.consumeProcessOutput(outputStream, errorStream)
        process.waitFor()
        
        def output = outputStream.toString()
        def error = errorStream.toString()
        
        if (process.exitValue() == 0) {
            println "Upload successful!"
            println "Response: ${output}"
        } else {
            println "Upload failed!"
            println "Error: ${error}"
            println "Output: ${output}"
            throw new GradleException("Failed to upload to Sonatype Central")
        }
    }
}
