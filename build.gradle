plugins {
    id 'com.adarshr.test-logger' version '2.1.1'
    id 'com.avast.gradle.docker-compose' version '0.14.0'
    id 'com.jfrog.bintray' version '1.8.5'
    id 'org.unbroken-dome.test-sets' version '3.0.1'
}

apply plugin: 'java'
apply plugin: 'java-library'
apply plugin: 'jacoco'
apply plugin: 'maven-publish'

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    jcenter()
}

/**
 * Defines test sets:
 *  - Unit Tests (test)  <-- existing default
 *  - Integration (integration)
 *
 * @plugin org.unbroken-dome.test-sets
 */
testSets {
    integration
}

/**
 * Defines all dependencies.
 *
 * @see https://docs.gradle.org/6.0.1/userguide/java_library_plugin.html#sec:java_library_configurations_graph
 */
dependencies {
    api 'com.google.code.gson:gson:2.7'
    api 'com.squareup.okhttp3:okhttp:3.12.0'
    implementation 'org.apache.commons:commons-text:1.2'
    implementation 'javax.json:javax.json-api:1.0'  // Java EE interfaces
    runtimeOnly 'org.glassfish:javax.json:1.1'      // implementation for above interfaces

    testImplementation 'com.squareup.okhttp3:mockwebserver:3.4.1'
    testImplementation 'org.powermock:powermock-release-with-testng-mockito-dependencies:1.6.2'
    testImplementation 'org.testng:testng:6.9.12'

    integrationImplementation 'org.seleniumhq.selenium:selenium-java:3.13.0'
}

/**
 * Generates Javadoc for the SDK.
 *
 * @plugin java
 */
javadoc {
    source = sourceSets.main.allJava
    classpath = configurations.compile
    destinationDir = file('docs')

    options.header = libDescription
    options.windowTitle = "${libName} - ${libVersion}"
    options.addBooleanOption('notimestamp', true)
}

/**
 * Customizes the jar MANIFEST.MF for generated jars.
 *
 * @plugin java
 */
jar {
    manifest {
        attributes('Implementation-Title': libName,
                'Implementation-Version': libVersion)
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

/**
 * If the selenium.debug system property is set, selenium will use  a local
 * ChromeDriver instance instead of Docker.
 *
 * @plugin com.avast.gradle.docker-compose
 */
if (!System.properties.containsKey('selenium.debug')) {
    dockerCompose.isRequiredBy integration
}

/**
 * Generates a jar with sources.
 *
 * @plugin java
 */
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

/**
 * Generates a jar with generated Javadoc.
 *
 * @plugin java
 */
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'docs'
    from javadoc.destinationDir
}

/**
 * Defines additional artifacts to be generated.
 */
artifacts {
    archives sourcesJar
    archives javadocJar
}

/**
 * Configures all test tasks.
 *
 * @plugin com.adarshr.test-logger
 * @plugin java
 */
tasks.withType(Test) {
    useTestNG {
        preserveOrder true
    }

    testlogger {
        showStandardStreams true
        theme 'mocha'
    }
}

/**
 * Executes all integration tests.
 *
 * @plugin com.avast.gradle.docker-compose
 * @plugin org.unbroken-dome.test-sets
 * @plugin java
 */
integration {
    if (!System.properties.containsKey('selenium.debug')) {
        doFirst {
            def seleniumInfo = dockerCompose.servicesInfos['selenium-hub'].firstContainer

            systemProperty 'selenium.browser', 'chrome'
            systemProperty 'selenium.host', seleniumInfo.host
            systemProperty 'selenium.port', seleniumInfo.ports[4444]
        }
    } else {
        systemProperty 'selenium.debug', System.getProperty('selenium.debug')
    }
}

check.dependsOn integration

/**
 * Configures coverage reporting.
 *
 * @plugin jacoco
 */
jacoco {
    reportsDirectory = file("${buildDir}/reports/coverage")
}

/**
 * Generates coverage reports for the unit tests.
 *
 * @plugin jacoco
 */
jacocoTestReport {
    reports {
        html.enabled = true
        html.destination = file("${buildDir}/reports/coverage/test/html")

        xml.enabled = true
        xml.destination = file("${buildDir}/reports/coverage/test/report.xml")
    }
}

/**
 * Generates coverage reports for the integration tests.
 *
 * @plugin jacoco
 */
jacocoIntegrationReport {
    dependsOn integration

    reports {
        html.enabled = true
        html.destination = file("${buildDir}/reports/coverage/integration/html")

        xml.enabled = true
        xml.destination = file("${buildDir}/reports/coverage/integration/report.xml")
    }
}

/**
 * Generates all coverage reports after running tests.
 *
 * @plugin jacoco
 */
task coverage {
    dependsOn check
    dependsOn jacocoTestReport
    dependsOn jacocoIntegrationReport
}

/**
 * Generates updated markdown documentation using the markdown template files.
 */
task markdown(type: Copy) {
    def date = new Date()
    def licenseYear = date.format('yyyy')

    from './'
    into './'
    include '*.mdt'
    rename '^(.*)\\.mdt$', '$1.md'
    expand(libGroup: libGroup, libName: libName, libVersion: libVersion, year: licenseYear)
    filteringCharset = 'UTF-8'
}

/**
 * Configures Bintray publishing.
 *
 * @plugin com.jfrog.bintray
 */
bintray {
    user = bintrayUser
    key = bintrayKey
    publish = true
    publications = ['SmartcarPublication']
    pkg {
        repo = bintrayRepo
        name = libName
        userOrg = bintrayOrg
        licenses = [licenseId]
        desc = libDescription
        websiteUrl = developerWebsite
        issueTrackerUrl = developerIssues
        vcsUrl = vcsRepoUrl
        publicDownloadNumbers = true
        githubRepo = vcsGithubRepo
        version {
            name = libVersion
            vcsTag = 'v' + libVersion
            released = new Date()
        }
    }
}

/**
 * Configures packaging of modules/artifacts to publish.
 *
 * @plugin maven-publish
 */
publishing {
    publications {
        SmartcarPublication(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
            groupId libGroup
            artifactId libName
            version libVersion
            pom.withXml {
                def root = asNode()

                root.appendNode('name', libName)
                root.appendNode('description', libDescription)
                root.appendNode('url', libUrl)
                root.appendNode('licenses').
                        appendNode('license').
                        appendNode('name', licenseName).parent().
                        appendNode('url', licenseUrl).parent().
                        appendNode('distribution', 'repo')
                root.appendNode('developers').
                        appendNode('developer').
                        appendNode('id', developerId).parent().
                        appendNode('name', developerName).parent().
                        appendNode('email', developerEmail)
                root.appendNode('scm').
                        appendNode('url', vcsRepoUrl).parent()
            }
        }
    }
}
